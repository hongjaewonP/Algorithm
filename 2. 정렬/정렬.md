## 정렬

### 1. 버블 정렬
시간 복잡도는 O(n^2)
다른 정렬에 비해 시간 복잡도가 크지만 구현이 쉽다.
자기 옆의 데이터와 크기를 비교해서 더 큰 놈을 왼쪽으로 swap 시키는 방법이다.

5개의 숫자가 담긴 배열에 대해
0번 루프 : 0,1번째 숫자 비교 및 스왑 > 1,2번째 숫자 비교 및 스왑 > 2,3번째 숫자 비교 및 스왑 > 3,4번째 숫자 비교 및 스왑 
1번 루프 : 0,1번째 숫자 비교 및 스왑 > 1,2번째 숫자 비교 및 스왑 > 2,3번째 숫자 비교 및 스왑 
2번 루프 : 0,1번째 숫자 비교 및 스왑 > 1,2번째 숫자 비교 및 스왑
3번 루프 : 0,1번째 숫자 비교 및 스왑

* 만약 맨 처음 루프 돌릴 때 swap이 한 번도 발생하지 않았다면 이미 모든 데이터가 정렬됐다는 뜻이므로 프로세스를 종료시켜도 된다. 

```Bubble.java
import java.util.Arrays;

public class Bubble{
	public static void main(String[]args){
		int[] arr = {45, 1, 12, 15, 27, 3, 7};
		int temp = 0;
		for(int i = 0; i < arr.length - 1; i++) {
			for(int j= 1 ; j < arr.length-i; j++) {
				if(arr[j]<arr[j-1]) {
					temp = arr[j-1];
					arr[j-1] = arr[j];
					arr[j] = temp;
				}
			}
		}
		System.out.println(Arrays.toString(arr));		
	}
}
```



### 2. 선택 정렬
시간 복잡도는 O(n^2)
구현도 복잡하고 시간 복잡도도 커서 효율적이지 않아 코테에선 잘 쓰이지 않는다. 그래도 원리는 숙지하자.
배열 내에서 최댓값을 찾아 맨 뒤와 swap하고, 그다음으로 큰 값을 찾아 뒤에서 2번째 위치와 swap하기를 반복한다.

5개의 숫자가 담긴 배열에 대해
0번 루프 : 0~4번째 수 중 가장 큰 수를 찾아 4번째 수와 swap
1번 루프 : 0~3번째 수 중 그다음으로 큰 수를 찾아 3번째 수와 swap
2번 루프 : 0~2번째 수 중 그다음으로 큰 수를 찾아 2번째 수와 swap
3번 루프 : 0~1번째 수 중 그다음으로 큰 수를 찾아 1번째 수와 swap

```Selection.java
public class Selection{
	public static void main(String[]args){
		int[] list = {45, 1, 12, 15, 27, 3, 7};
	    int indexMin, temp;

	    for (int i = 0; i < list.length - 1; i++) {
	        indexMin = i;
	        for (int j = i + 1; j < list.length; j++) {
	            if (list[j] < list[indexMin]) {
	                indexMin = j;
	            }
	        }
	        temp = list[indexMin];
	        list[indexMin] = list[i];
	        list[i] = temp;
	    }		
	}
}
```


### 3. 삽입 정렬
시간 복잡도는 O(n^2)
다른 정렬에 비해 시간 복잡도가 크지만 구현이 쉽다.
데이터들을 자기 이전 정렬된 데이터와 크기를 비교해 맞는 자리에 끼워넣는다. 

5개의 숫자가 담긴 배열에 대해
0번 루프 : 1번째 숫자를 0번째 숫자와 비교해 작으면 0 앞에, 크면 0 뒤에 둔다.
1번 루프 : 2번째 숫자를 0번째 숫자와 비교해 작으면 0 앞에, 크면 1번째 숫자와 비교해 작으면 0과 1 사이, 크면 1 뒤에 둔다.
2번 루프 : 3번째 숫자를 0번째 숫자와 비교해 작으면 0 앞에, 크면 1번째 숫자와 비교해 작으면 0과 1 사이, 크면 2번째 숫자와 비교해 작으면 1과 2사이, 크면 2 뒤에 둔다.
3번 루프 : 4번째 숫자를 0번째 숫자와 비교해 작으면 0 앞에, 크면 1번째 숫자와 비교해 작으면 0과 1 사이, 크면 2번째 숫자와 비교해 작으면 1과 2사이, 크면 3번째 숫자와 비교해 작으면 2와 3 사이, 크면 3 뒤에 둔다.

* 자기 인덱스 앞에 정렬된 데이터들을 이진탐색으로 자신의 위치를 찾는다면 시간 복잡도를 줄일 수 있다.
* 그러나 자리를 찾아도 그곳에 삽입하는 데에 시간이 많이 걸려 코테에선 많이 쓰이지 않는다!!!  

```Insert.java
public class Insert{
	public static void main(String[]args){
		int[] arr = {45, 1, 12, 15, 27, 3, 7};

	    for(int index = 1 ; index < arr.length ; index++){

	        int temp = arr[index];
	        int aux = index - 1;

	        while( (aux >= 0) && ( arr[aux] > temp ) ) {

	           arr[aux + 1] = arr[aux];
	           aux--;
	        }
	        arr[aux + 1] = temp;
	     }		
	}
}


```


### 4. 퀵 정렬
평균 시간 복잡도는 O(nlogn) 최악의 시간 복잡도는 O(n^2).
기준값 pivot에 따라 시간 복잡도가 달라진다. 

5개의 숫자가 담긴 배열에 대해
4번째 숫자를 피봇으로 정하고 0과 3을 피봇과 비교한다. 0이 4번보다 작으면 1로 옮기고, 3이 4번보다 크면 2로 옮긴다.
만약  0이 4번보다 크면 가만히 있는다
만약 3이 4번보다 작으면 가만히 있는다
만약 위의 두 조건이 동시에 일어나면 두 숫자를 swap한다.
start와 end가 만나는 지점과 4번을 비교해 4번이 작으면 swap하고, 크면 가만히 놔둔다.

다시 pivot을 start와 end가 만나는 지점 +-1로 지정하여 두 그룹을 정렬한다.

그룹의 원소가 1개가 되면 그 부분은 정렬을 끝낸다.

```Quick.java
public void quickSort(int[] arr, int left, int right) {
    // base condition
    if (left >= right) {
        return;
    }
    int pivot = arr[right];
    
    int sortedIndex = left;
    for (int i = left; i < right; i++) {
        if (arr[i] <= pivot) {
            swap(arr, i, sortedIndex);
            sortedIndex++;
        }
    }
    swap(arr, sortedIndex, right);
    quickSort(arr, left, sortedIndex - 1);
    quickSort(arr, sortedIndex + 1, right);
}

private void swap(int[] arr, int i, int j) {
    int tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}
```



### 5. 기수 정렬
