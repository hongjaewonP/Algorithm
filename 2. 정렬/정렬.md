## 정렬

### 1. 버블 정렬
시간 복잡도는 O(n^2)
다른 정렬에 비해 시간 복잡도가 크지만 구현이 쉽다.
자기 옆의 데이터와 크기를 비교해서 더 큰 놈을 왼쪽으로 swap 시키는 방법이다.

5개의 숫자가 담긴 배열에 대해
0번 루프 : 0,1번째 숫자 비교 및 스왑 > 1,2번째 숫자 비교 및 스왑 > 2,3번째 숫자 비교 및 스왑 > 3,4번째 숫자 비교 및 스왑 
1번 루프 : 0,1번째 숫자 비교 및 스왑 > 1,2번째 숫자 비교 및 스왑 > 2,3번째 숫자 비교 및 스왑 
2번 루프 : 0,1번째 숫자 비교 및 스왑 > 1,2번째 숫자 비교 및 스왑
3번 루프 : 0,1번째 숫자 비교 및 스왑

* 만약 맨 처음 루프 돌릴 때 swap이 한 번도 발생하지 않았다면 이미 모든 데이터가 정렬됐다는 뜻이므로 프로세스를 종료시켜도 된다. 

```Bubble.java
import java.util.Arrays;

public class Bubble{
	public static void main(String[]args){
		int[] arr = {45, 1, 12, 15, 27, 3, 7};
		int temp = 0;
		for(int i = 0; i < arr.length - 1; i++) {
			for(int j= 1 ; j < arr.length-i; j++) {
				if(arr[j]<arr[j-1]) {
					temp = arr[j-1];
					arr[j-1] = arr[j];
					arr[j] = temp;
				}
			}
		}
		System.out.println(Arrays.toString(arr));		
	}
}
```



### 2. 선택 정렬
시간 복잡도는 O(n^2)
구현도 복잡하고 시간 복잡도도 커서 효율적이지 않아 코테에선 잘 쓰이지 않는다. 그래도 원리는 숙지하자.
배열 내에서 최댓값을 찾아 맨 뒤와 swap하고, 그다음으로 큰 값을 찾아 뒤에서 2번째 위치와 swap하기를 반복한다.

5개의 숫자가 담긴 배열에 대해
0번 루프 : 0~4번째 수 중 가장 큰 수를 찾아 4번째 수와 swap
1번 루프 : 0~3번째 수 중 그다음으로 큰 수를 찾아 3번째 수와 swap
2번 루프 : 0~2번째 수 중 그다음으로 큰 수를 찾아 2번째 수와 swap
3번 루프 : 0~1번째 수 중 그다음으로 큰 수를 찾아 1번째 수와 swap

```Selection.java
public class Selection{
	public static void main(String[]args){
		int[] list = {45, 1, 12, 15, 27, 3, 7};
	    int indexMin, temp;

	    for (int i = 0; i < list.length - 1; i++) {
	        indexMin = i;
	        for (int j = i + 1; j < list.length; j++) {
	            if (list[j] < list[indexMin]) {
	                indexMin = j;
	            }
	        }
	        temp = list[indexMin];
	        list[indexMin] = list[i];
	        list[i] = temp;
	    }		
	}
}
```


### 3. 삽입 정렬

### 4. 퀵 정렬

### 5. 기수 정렬
