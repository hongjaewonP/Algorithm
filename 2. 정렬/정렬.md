## 정렬

### 1. 버블 정렬
시간 복잡도는 O(n^2)
다른 정렬에 비해 시간 복잡도가 크지만 구현이 쉽다.
자기 옆의 데이터와 크기를 비교해서 더 큰 놈을 왼쪽으로 swap 시키는 방법이다.

5개의 숫자가 담긴 배열에 대해
0번 루프 : 0,1번째 숫자 비교 및 스왑 > 1,2번째 숫자 비교 및 스왑 > 2,3번째 숫자 비교 및 스왑 > 3,4번째 숫자 비교 및 스왑 
1번 루프 : 0,1번째 숫자 비교 및 스왑 > 1,2번째 숫자 비교 및 스왑 > 2,3번째 숫자 비교 및 스왑 
2번 루프 : 0,1번째 숫자 비교 및 스왑 > 1,2번째 숫자 비교 및 스왑
3번 루프 : 0,1번째 숫자 비교 및 스왑

* 만약 맨 처음 루프 돌릴 때 swap이 한 번도 발생하지 않았다면 이미 모든 데이터가 정렬됐다는 뜻이므로 프로세스를 종료시켜도 된다. 

```Bubble.java
import java.util.Arrays;

public class Bubble{
	public static void main(String[]args){
		int[] arr = {45, 1, 12, 15, 27, 3, 7};
		int temp = 0;
		for(int i = 0; i < arr.length - 1; i++) {
			for(int j= 1 ; j < arr.length-i; j++) {
				if(arr[j]<arr[j-1]) {
					temp = arr[j-1];
					arr[j-1] = arr[j];
					arr[j] = temp;
				}
			}
		}
		System.out.println(Arrays.toString(arr));		
	}
}
```



### 2. 선택 정렬
시간 복잡도는 O(n^2)
구현도 복잡하고 시간 복잡도도 커서 효율적이지 않아 코테에선 잘 쓰이지 않는다. 그래도 원리는 숙지하자.
배열 내에서 최댓값을 찾아 맨 뒤와 swap하고, 그다음으로 큰 값을 찾아 뒤에서 2번째 위치와 swap하기를 반복한다.

5개의 숫자가 담긴 배열에 대해
0번 루프 : 0~4번째 수 중 가장 큰 수를 찾아 4번째 수와 swap
1번 루프 : 0~3번째 수 중 그다음으로 큰 수를 찾아 3번째 수와 swap
2번 루프 : 0~2번째 수 중 그다음으로 큰 수를 찾아 2번째 수와 swap
3번 루프 : 0~1번째 수 중 그다음으로 큰 수를 찾아 1번째 수와 swap

```Selection.java
public class Selection{
	public static void main(String[]args){
		int[] list = {45, 1, 12, 15, 27, 3, 7};
	    int indexMin, temp;

	    for (int i = 0; i < list.length - 1; i++) {
	        indexMin = i;
	        for (int j = i + 1; j < list.length; j++) {
	            if (list[j] < list[indexMin]) {
	                indexMin = j;
	            }
	        }
	        temp = list[indexMin];
	        list[indexMin] = list[i];
	        list[i] = temp;
	    }		
	}
}
```


### 3. 삽입 정렬
시간 복잡도는 O(n^2)
다른 정렬에 비해 시간 복잡도가 크지만 구현이 쉽다.
데이터들을 자기 이전 정렬된 데이터와 크기를 비교해 맞는 자리에 끼워넣는다. 

5개의 숫자가 담긴 배열에 대해
0번 루프 : 1번째 숫자를 0번째 숫자와 비교해 작으면 0 앞에, 크면 0 뒤에 둔다.
1번 루프 : 2번째 숫자를 0번째 숫자와 비교해 작으면 0 앞에, 크면 1번째 숫자와 비교해 작으면 0과 1 사이, 크면 1 뒤에 둔다.
2번 루프 : 3번째 숫자를 0번째 숫자와 비교해 작으면 0 앞에, 크면 1번째 숫자와 비교해 작으면 0과 1 사이, 크면 2번째 숫자와 비교해 작으면 1과 2사이, 크면 2 뒤에 둔다.
3번 루프 : 4번째 숫자를 0번째 숫자와 비교해 작으면 0 앞에, 크면 1번째 숫자와 비교해 작으면 0과 1 사이, 크면 2번째 숫자와 비교해 작으면 1과 2사이, 크면 3번째 숫자와 비교해 작으면 2와 3 사이, 크면 3 뒤에 둔다.

* 자기 인덱스 앞에 정렬된 데이터들을 이진탐색으로 자신의 위치를 찾는다면 시간 복잡도를 줄일 수 있다.
* 그러나 자리를 찾아도 그곳에 삽입하는 데에 시간이 많이 걸려 코테에선 많이 쓰이지 않는다!!!  

```Insert.java
public class Insert{
	public static void main(String[]args){
		int[] arr = {45, 1, 12, 15, 27, 3, 7};

	    for(int index = 1 ; index < arr.length ; index++){

	        int temp = arr[index];
	        int aux = index - 1;

	        while( (aux >= 0) && ( arr[aux] > temp ) ) {

	           arr[aux + 1] = arr[aux];
	           aux--;
	        }
	        arr[aux + 1] = temp;
	     }		
	}
}


```


### 4. 퀵 정렬

### 5. 기수 정렬
