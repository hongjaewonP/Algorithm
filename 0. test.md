## 시간 복잡도

시간 복잡도란? 연산 횟수.

시간복잡도 유형 3가지
- 빅 오메가, best case
- 빅 세타, average case
- 빅 오, worst case

>> 우리는 항상 worst case 를 염두에 둬야 함. 코테에서 테스트 셋은 굉장히 다양하고 복잡하기 때문에 항상 최악의 상황을 생각하자!

시간 복잡도를 줄이는 방법.
(1) 알고리즘을 적합한 걸 쓰자.
```
//예시 문제
N 개의 수가 주어졌을 때 오름차순 정렬하는 프로그램을 작성하라는 문제가 주어졌다.
입력의 1번째 줄에는 수의 개수 N(1<=N<=1,000,000), 2번째 줄부터는 N개의 줄에 숫자가 주어진다. 수는 중복되지 않는다.
제한 시간은 2초.
```
1. 먼저 입력을 살펴본다. 주어진 숫자는 백만 개 이하이다. 
2. 제한시간을 본다. 2초이하로 해결해야 하니 연산 횟수는 2억번 이하여야 한다.
연산 횟수 = 알고리즘 시간 복잡도 X 데이터 크기. 
예를 들어 버블 정렬로 문제를 푼다면, 버블 정렬의 시간 복잡도는 N^2이므로 (100만)^2 의 연산횟수가 나온다. -> 버블 정렬은 부적합 알고리즘!!
만약 병합 정렬로 푼다면 1,000,000log(1,000,000) < 2억 이므로 병합 정렬로 풀어야 한다. 

(2) 내가 짠 코드가 효율적인지 따지고 수정하자.
내가 짠 코드의 시간 복잡도를 직접 계산하는 것이다.
계산 방법 = 상수는 계산에서 제외하고, 가장 많이 중첩된 반복문의 수행횟수가 시간 복잡도의 기준이 된다. 



## 디버깅

디버깅이란: 코드의 논리 오류를 탐색하고 수정하게 해주는 도구.

* 디버깅하는 법.
디버깅 하고자 하는 줄에 중단점을 설정하고, 디버깅 기능을 실행한다.
f6(이클립스 기준)을 통해 test를 진행시키며 오류를 찾는다.
시간 내에 오류를 찾아 고쳐야 하는데, 전체적으로 스캔을 해주는 디버깅이 로그보다 빠름. 


* 팁.
팩토리얼이든 경우의 수든 등등.. 숫자가 크게 나올 거 같은데 음수가 나온다면 int 말고 long 형으로 하자. 애초에 코딩 테스트에서 자료형은 처음부터 int 안 쓰고 long을 쓰는 게 더 안전함!!
