## 시간 복잡도

시간 복잡도란? 연산 횟수.

시간복잡도 유형 3가지
- 빅 오메가, best case
- 빅 세타, average case
- 빅 오, worst case

>> 우리는 항상 worst case 를 염두에 둬야 함. 코테에서 테스트 셋은 굉장히 다양하고 복잡하기 때문에 항상 최악의 상황을 생각하자!

시간 복잡도를 줄이는 방법.
(1) 알고리즘을 적합한 걸 쓰자.
```
//예시 문제
N 개의 수가 주어졌을 때 오름차순 정렬하는 프로그램을 작성하라는 문제가 주어졌다.
입력의 1번째 줄에는 수의 개수 N(1<=N<=1,000,000), 2번째 줄부터는 N개의 줄에 숫자가 주어진다. 수는 중복되지 않는다.
제한 시간은 2초.
```
1. 먼저 입력을 살펴본다. 주어진 숫자는 백만 개 이하이다. 
2. 제한시간을 본다. 2초이하로 해결해야 하니 연산 횟수는 2억번 이하여야 한다.
연산 횟수 = 알고리즘 시간 복잡도 X 데이터 크기. 
예를 들어 버블 정렬로 문제를 푼다면, 버블 정렬의 시간 복잡도는 N^2이므로 (100만)^2 의 연산횟수가 나온다. -> 버블 정렬은 부적합 알고리즘!!
만약 병합 정렬로 푼다면 1,000,000log(1,000,000) < 2억 이므로 병합 정렬로 풀어야 한다. 

(2) 내가 짠 코드가 효율적인지 따지고 수정하자.
내가 짠 코드의 시간 복잡도를 직접 계산하는 것이다.
계산 방법 = 상수는 계산에서 제외하고, 가장 많이 중첩된 반복문의 수행횟수가 시간 복잡도의 기준이 된다. 



## 디버깅
